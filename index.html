<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content, maximum-scale=1.0, user-scalable=no">
    <title>Neural-Lite</title>
    <style>
        /* =========================================
                Aqua/Skeuomorphic Style System
           ========================================= */
        :root {
            --aqua-blue-top: #73b6e7;
            --aqua-blue-bot: #1c62b5;
            --metal-grey-top: #e8e8e8;
            --metal-grey-bot: #b0b0b0;
            --pinstripe: #e0e0e0;
        }

        body {
            font-family: "Lucida Grande", "Lucida Sans Unicode", "STHeiti", "华文黑体", Helvetica, Arial, sans-serif;
            background-color: #c5c5c5;
            /* 经典的 OS X 条纹背景 */
            background-image: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 1px,
                    #dcdcdc 1px,
                    #dcdcdc 2px);
            background-size: 100% 4px;
            height: 100vh;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* 模拟 OS X 窗口 */
        .window-frame {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            background: #ececec;
            border-radius: 5px 5px 3px 3px;
            box-shadow:
                0 20px 50px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* 顶部标题栏 (Brushed Metal / Gradient) */
        .header {
            background: linear-gradient(to bottom, #e6e6e6 0%, #d0d0d0 50%, #b8b8b8 51%, #c0c0c0 100%);
            padding: 0 15px;
            height: 36px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
            flex-shrink: 0;
            cursor: default;
        }

        .header h1 {
            margin: 0;
            font-size: 14px;
            color: #333;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.7);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* 模拟红绿灯窗口按钮 - Aqua / Snow Leopard 风格 */
        .window-controls {
            display: flex;
            gap: 8px;
            /*稍微拉大一点间距以适应阴影 */
            align-items: center;
        }

        .win-btn {
            width: 14px;
            /* 稍微增大一点尺寸以展示细节 */
            height: 14px;
            border-radius: 50%;
            position: relative;
            /* 为伪元素定位做准备 */
            /* 核心边框：深色半透明，产生镶嵌感 */
            border: 1px solid rgba(0, 0, 0, 0.4);
            /* 阴影层叠：
            1. 外部投影 (drop-shadow)
            2. 内部顶部高光边框 (inset top light)
            3. 内部底部阴影 (inset bottom shadow) 增加体积感
            */
            box-shadow:
                0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 1px rgba(0, 0, 0, 0.2);
        }

        /* 标志性的“玻璃反光”高光 - 使用伪元素实现上半部分的强反光 */
        .win-btn::after {
            content: '';
            position: absolute;
            top: 1px;
            left: 2px;
            right: 2px;
            height: 5px;
            /* 占据上半部分 */
            /* 垂直的白色渐变，模拟灯光反射 */
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.85) 0%, rgba(255, 255, 255, 0.1) 100%);
            /* 椭圆形的倒角 */
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
        }

        /* 红色按钮 - 深红到鲜红的渐变 */
        .close {
            background: linear-gradient(to bottom, #ff7b7b 0%, #ce1315 100%);
        }

        /* 黄色按钮 - 琥珀色渐变 */
        .min {
            background: linear-gradient(to bottom, #ffdf60 0%, #d89602 100%);
        }

        /* 绿色按钮 - 宝石绿渐变 */
        .max {
            background: linear-gradient(to bottom, #98e858 0%, #2a9d16 100%);
        }

        /* 状态栏文字样式保持不变，微调阴影增强凹陷感 */
        .status {
            font-size: 11px;
            color: #444;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.6);
            margin-left: 5px;
        }

        /* 聊天主窗口 - 类似 iChat */
        #chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #fff;
            /* iChat 白色背景 */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            scroll-behavior: smooth;
        }

        /* 滚动条拟物化 */
        #chat-container::-webkit-scrollbar {
            width: 12px;
        }

        #chat-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-left: 1px solid #ccc;
        }

        #chat-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 6px;
            border: 2px solid #f1f1f1;
        }

        #chat-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .message-row {
            display: flex;
            gap: 10px;
            width: 100%;
            align-items: flex-end;
        }

        .message-row.user {
            justify-content: flex-end;
        }

        /* 头像加上投影和边框 */
        .avatar {
            width: 40px;
            height: 40px;
            flex-shrink: 0;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        .ai-avatar {
            background: linear-gradient(to bottom, #dcdcdc 0%, #a0a0a0 100%);
            color: #444;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.6);
        }

        .user-avatar {
            background: linear-gradient(to bottom, #8dbce8 0%, #296bb1 100%);
            color: white;
            text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.3);
        }

        /* =========================================
           Aqua 玻璃风格对话框 (Glass Bubbles)
        ========================================= */
        /* 基础气泡结构 - 胶囊形状 */
        .bubble {
            padding: 8px 15px;
            border-radius: 20px;
            /* 更加圆润的胶囊形 */
            font-size: 13px;
            line-height: 1.4;
            max-width: 70%;
            position: relative;
            /* 玻璃质感的边框和投影 */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 0, 0, 0.3);
            overflow: hidden;
            /* 裁剪内部的高光层 */
            z-index: 1;
        }

        /* 核心：添加 Aqua 风格的玻璃反光层 (Glassy Gloss) */
        .bubble::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%;
            /* 占据上半部分 */
            /* 经典的高光渐变 */
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0.7) 0%,
                    rgba(255, 255, 255, 0.15) 100%);
            border-radius: 20px 20px 10px 10px;
            /* 匹配气泡顶部的圆角 */
            pointer-events: none;
            /* 确保不影响文字选择 */
        }

        /* AI 气泡 - 替换为 Aqua 石墨灰玻璃风格 */
        /* AI 气泡 - Aqua 银色风格 (修正版：文字位于最上层) */
        .ai-bubble {
            /* 1. 字体设置：使用深炭灰色，配合白色向下投影，形成浮雕感 */
            color: #262626;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.8);
            border-color: #99aab5;
            /* 2. 背景核心修改：使用“多重背景”替代 ::after 伪元素 
       这样高光层就变成了背景的一部分，永远位于文字下方，不会挡住文字。
       图层顺序（逗号分隔，越写在前面层级越高）：
       第一层：高光层 (Gloss) - 也就是原来的 ::after 效果
       第二层：金属底色 (Silver Base) - 经典的 Aqua 银色渐变
    */
            background-image:
                /* --- 高光层 (模拟玻璃反光) --- */
                linear-gradient(to bottom,
                    rgba(255, 255, 255, 0.6) 0%,
                    rgba(255, 255, 255, 0.1) 100%),
                /* --- 金属底色层 (Silver) --- */
                linear-gradient(to bottom,
                    #f2f6f8 0%,
                    /* 顶部极浅蓝灰 */
                    #d8e1e7 50%,
                    /* 上半部结束 */
                    #b5c6d0 51%,
                    /* 硬切边 */
                    #e0eff9 100%
                    /* 底部 */
                );
            /* 3. 控制背景大小和重复 */
            /* 第一层(高光)只占高度的 50% | 第二层(底色)占 100% */
            background-size: 100% 50%, 100% 100%;
            background-repeat: no-repeat;
        }

        /* 4. 关键步骤：隐藏原本通用的 ::after 高光层 
*/
        .ai-bubble::after {
            display: none;
        }

        /* 用户气泡 - 经典的 Aqua 蓝色玻璃 */
        .user-bubble {
            /* 经典的 OS X 蓝色两段式渐变 */
            background: linear-gradient(to bottom,
                    #8ec1f5 0%,
                    #529df3 50%,
                    #267ce8 51%,
                    #4e9af2 100%);
            color: #fff;
            border-color: #16569e;
            text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.3);
            /* 文字凹陷效果 */
        }

        /* 底部输入区 - 金属质感 */
        .input-wrapper {
            background: linear-gradient(to bottom, #dcdcdc 0%, #b0b0b0 100%);
            padding: 10px 15px;
            border-top: 1px solid #888;
            display: flex;
            align-items: center;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
            height: 50px;
            flex-shrink: 0;
        }

        .input-box {
            width: 100%;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* 搜索框风格输入框 */
        input {
            flex: 1;
            background: #fff;
            border: 1px solid #777;
            border-bottom-color: #999;
            color: #333;
            padding: 6px 12px;
            border-radius: 15px;
            outline: none;
            font-size: 13px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.5);
            font-family: "Lucida Grande", "Lucida Sans Unicode", "STHeiti", "华文黑体", sans-serif;
            /* 新增这一行 */
        }

        input:focus {
            /* 经典的 Mac OS 蓝色光晕 */
            box-shadow: 0 0 3px 2px rgba(130, 190, 255, 0.8), inset 0 2px 4px rgba(0, 0, 0, 0.2);
            border-color: #518cca;
        }

        /* 拟物化按钮 (Gel Button) */
        button {
            font-family: "Lucida Grande", "Lucida Sans Unicode", "STHeiti", "华文黑体", sans-serif;
            /* 新增这一行 */
            background: linear-gradient(to bottom, #ffffff 0%, #f1f1f1 49%, #e1e1e1 51%, #f6f6f6 100%);
            color: #333;
            border: 1px solid #888;
            padding: 5px 20px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 1);
            text-shadow: 0 1px 0 #fff;
            transition: all 0.1s;
        }

        button:active {
            background: linear-gradient(to bottom, #d0d0d0 0%, #e0e0e0 100%);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* 蓝色主按钮变体 */
        button.primary {
            background: linear-gradient(to bottom, #8fcaf9 0%, #6cb4f2 49%, #348cdb 51%, #2778c1 100%);
            color: white;
            text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.4);
            border: 1px solid #1a5189;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        button.primary:hover {
            filter: brightness(1.05);
        }

        button.primary:active {
            background: linear-gradient(to bottom, #2c6fb5 0%, #468ccf 100%);
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        .similarity-score {
            font-size: 0.7em;
            color: #666;
            margin-top: 5px;
            display: block;
            text-align: right;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.6);
        }

        ul {
            margin: 5px 0 5px 20px;
            padding: 0;
        }

        b {
            color: #000;
        }

        /* =========================================
       新增： Aqua/iChat 动画效果
       ========================================= */
        /* 定义弹出动画：带有轻微的位移和缩放，模拟“弹出”感 */
        @keyframes aquaPop {
            0% {
                opacity: 0;
                transform: translateY(20px) scale(0.9);
                /* 从下方稍小一点的位置开始 */
            }

            50% {
                opacity: 1;
                /* 中途就完全显示，防止闪烁 */
            }

            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                /* 回到正常位置 */
            }
        }

        /* 应用到消息行 */
        .message-row {
            /* 0.25s: 动画持续时间，短促有力
           cubic-bezier(0.15, 1, 0.5, 1): 经典的 Apple "Ease-Out" 曲线，
           起步快，结束时有非常平滑的减速，类似物理惯性。
        */
            animation: aquaPop 0.35s cubic-bezier(0.15, 1, 0.5, 1) forwards;
            /* 初始状态设为不可见，防止动画加载前闪现 */
            opacity: 0;
            /* 设置变换原点为底部，让气泡看起来是从下往上长出来的 */
            transform-origin: center bottom;
            /* 优化渲染性能 */
            will-change: transform, opacity;
        }

        /* 可选：让用户的消息和AI的消息从不同侧面稍微倾斜弹出 (更拟物) */
        .message-row.user {
            transform-origin: right bottom;
        }

        .message-row.ai {
            transform-origin: left bottom;
        }

        /* =========================================
           移动端适配 (Mobile Responsive)
           屏幕宽度小于 768px 时生效
           ========================================= */
        @media screen and (max-width: 768px) {

            /* ★★★ 新增：只在手机上把标题变成可点击的样子 ★★★ */
            .header h1 {
                /* cursor: pointer;  <-- 删掉或注释掉这行，手机上不需要手型 */
                user-select: none;
                
                /* 1. 去掉原本的虚线 */
                text-decoration: none; 
                border-bottom: none;

                /* 2. 强制居中 */
                flex: 1;            /* 让标题占据中间剩余空间 */
                text-align: center; /* 文字水平居中 */
                margin: 0;          /* 清除默认边距 */
            }
            
            /* ★★★ 新增：防止手机端把弹窗的关闭按钮也隐藏了 ★★★ */
            /* 原本的代码把所有 .window-controls 都隐藏了，我们要把弹窗里的显示出来 */
            .modal-window .window-controls {
                display: flex !important;
            }

            /* 1. 让 Body 撑满屏幕，取消居中布局 */
            body {
                height: 100%;
                /* 防止键盘弹出时挤压 */
                display: block;
                /* 取消 Flex 居中 */
                background: #ececec;
                /* 背景色改为窗口底色，防止露馅 */
            }

            /* 2. 窗口框架：取消悬浮感，改为全屏铺满 */
            .window-frame {
                width: 100%;
                height: 100vh;
                /* 强制全高 */
                height: 100dvh;
                /* 针对移动端动态地址栏的优化 */
                max-width: none;
                /* 取消最大宽度限制 */
                border-radius: 0;
                /* 取消圆角 */
                box-shadow: none;
                /* 取消阴影 */
            }

            /* 3. 调整气泡宽度，手机屏幕窄，需要利用更多空间 */
            .bubble {
                max-width: 85%;
                /* 电脑是 70%，手机改宽一点 */
                font-size: 15px;
                /* 字体稍微大一点更易读 */
                padding: 10px 18px;
                /* 增大手指点击/视觉区域 */
            }

            /* 4. 头部优化 */
            .header {
                height: 44px;
                /* iOS 标准触控高度 */
            }

            .header h1 {
                font-size: 16px;
            }

            /* 5. 关键：防止 iOS Safari 输入框自动放大 */
            input {
                font-size: 16px;
                /* 小于 16px 会触发 iOS 放大镜效果，导致布局错乱 */
            }

            /* 6. 输入区域适配 */
            .input-wrapper {
                padding: 8px 10px;
                /* 减少左右边距 */
            }

            /* 隐藏非必要的装饰（可选），比如窗口控制红绿灯按钮在手机上没用 */
            .window-controls {
                display: none;
            }
        }

        /* =========================================
           自定义模态弹窗 (Custom Modal)
           ========================================= */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            /* 半透明遮罩 */
            backdrop-filter: blur(2px);
            /* 背景模糊效果 */
            z-index: 9999;
            display: none;
            /* 默认隐藏 */
            align-items: center;
            justify-content: center;
        }

        /* 复用 window-frame 样式，但做微调 */
        .modal-window {
            width: 300px;
            height: auto;
            max-width: 90%;
            background: #ececec;
            border-radius: 5px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: aquaPop 0.2s cubic-bezier(0.15, 1, 0.5, 1);
        }

        .modal-content {
            padding: 15px 20px 15px 20px;
            /* 上15px, 右20px, 下10px, 左20px */
            text-align: center;
            font-size: 13px;
            /* 字体稍微改小一号更精致 */
            color: #333;
            line-height: 1.4;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px 15px 20px;
            /* 底部留白减少到 15px */
        }

        /* 专门给取消按钮用的样式 */
        button.secondary {
            background: linear-gradient(to bottom, #f9f9f9 0%, #dcdcdc 100%);
        }

        .modal-window .win-btn.close:hover {
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="window-frame">
        <div class="header">
            <div class="window-controls">
                <div class="win-btn close" onclick="resetSystem()" style="cursor: pointer;" title="重置并清空记忆"></div>

                <div class="win-btn min"></div>
                <div class="win-btn max"></div>
            </div>
            <h1 onclick="if(window.innerWidth <= 768) resetSystem()">
                <span></span> Neural-Lite <span style="font-weight:normal; opacity:0.6; font-size: 0.9em;"> v1.0</span>
            </h1>
            <div class="status" id="db-status">准备就绪</div>
        </div>
        <div id="chat-container">
            <div class="message-row">
                <div class="avatar ai-avatar">AI</div>
                <div class="bubble ai-bubble">
                    你好！我是基于<b>模糊匹配算法</b>的本地 AI。<br>
                    <br>
                    试试问我：
                    <ul>
                        <li>“人类存在的意义是什么？”</li>
                        <li>“讲个笑话”</li>
                    </ul>
                    <div class="similarity-score">系统消息</div>
                </div>
            </div>
        </div>
        <div class="input-wrapper">
            <div class="input-box">
                <input type="text" id="user-input" placeholder="在此输入消息..." onkeypress="handleEnter(event)">
                <button class="primary" onclick="sendMessage()">发送</button>
            </div>
        </div>
    </div>
    <script>
        // =========================================================
        // 🔊 0. 音效系统 (多源冗余版 - 自动故障转移)
        // =========================================================
        // 1. 发送音效 (气泡声) - 单一源通常够用， Mixkit 比较稳
        const audioSent = new Audio('https://assets.mixkit.co/active_storage/sfx/2354/2354-preview.mp3');
        audioSent.volume = 0.7;
        // 2. 接收音效 (水滴声) - 定义多个备用源
        const recvSources = [
            // [首选] 原版 iChat 音效 (JSDelivr CDN)
            'https://cdn.jsdelivr.net/gh/extratone/macOSsystemsounds@main/mp3/ReceivedMessage.mp3',
            // [备用1] Mixkit 类似的水滴/提示音 (高速 CDN)
            'https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3',
            // [备用2] Wikimedia Commons (非常稳定，OGG格式兼容性好)
            'https://upload.wikimedia.org/wikipedia/commons/3/39/Water_drop_echo.ogg',
            // [备用3] 另一个清脆的提示音 (作为最后的兜底)
            'https://assets.mixkit.co/active_storage/sfx/2358/2358-preview.mp3'
        ];
        // 初始化接收音效对象
        const audioRecv = new Audio();
        audioRecv.volume = 0.8;
        let currentSrcIndex = 0; // 当前尝试的索引
        // ★★★ 核心逻辑：加载函数 ★★★
        function loadRecvAudio() {
            if (currentSrcIndex >= recvSources.length) {
                console.error("❌ 所有接收音效源均加载失败，请检查网络连接。");
                return;
            }
            // 设置当前源
            audioRecv.src = recvSources[currentSrcIndex];
            // 尝试加载
            // 注意：load() 只是开始加载，成功与否看事件
            audioRecv.load();
        }
        // 监听错误事件：如果当前源加载失败，自动切换下一个
        audioRecv.onerror = function () {
            console.warn(`⚠️ 音效源 [${currentSrcIndex}] 加载失败，正在尝试备用源...`);
            currentSrcIndex++; // 索引+1
            loadRecvAudio();   // 递归加载下一个
        };
        // 监听加载成功事件 (可选，用于调试)
        audioRecv.oncanplaythrough = function () {
            // console.log("接收音效加载成功，来源索引:", currentSrcIndex);
        };
        // 启动首次加载
        loadRecvAudio();
        // 预加载发送音效
        audioSent.load();
        // ★★★ 核心修复：解决浏览器拦截自动播放的问题 ★★★
        function unlockAudio() {
            // 瞬间播放并暂停接收音效，骗过浏览器的“用户交互”检测
            // 这里的 catch 是为了防止音频还没加载完就调用 play 报错
            audioRecv.play().then(() => {
                audioRecv.pause();
                audioRecv.currentTime = 0;
            }).catch(e => {
                // 如果是因为还在加载中导致的错误，忽略它
                // 如果是因为源错误，onerror 会处理
                console.log("音频预热/解锁中 (非致命错误)...");
            });
        }
        function playSound(type) {
            try {
                if (type === 'sent') {
                    audioSent.currentTime = 0;
                    // 播放发送音效
                    const playPromise = audioSent.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(e => console.log("发送音效播放受阻 (可能是交互未触发):", e));
                    }
                    // 关键：趁着用户点击发送，顺便解锁接收音效
                    unlockAudio();
                } else {
                    audioRecv.currentTime = 0;
                    // 播放接收音效
                    const playPromise = audioRecv.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(e => console.log("接收音效播放受阻:", e));
                    }
                }
            } catch (e) { console.log("音效系统错误:", e); }
        }
        // =========================================================
        // 1️⃣ 混合知识库：固定问答 + 动态模式匹配 (ELIZA 增强版)
        // =========================================================
        // A. 基础数据库 (用于确定的事实回答)
        const fixedKnowledge = [
            { "q": "你好", "a": ["嘿！{name}", "你好呀，今天心情怎么样？", "你好呀！很高兴见到你。", "哟，{name}来了！", "嗨"] },
            { "q": "人类存在的意义是什么？", "a": ["人类存在的意义在于体验、创造和连接。", "活着、感受、再选择。", "存在先于意义。", "在有限中创造价值。", "寻找快乐，也承受痛苦。", "你存在，就已经影响了别人", "存在是提问，生活是回答。", "意义不是被发现的，而是被创造的。"] },
            { "q": "今天星期几", "a": "今天是 " + ["周日", "周一", "周二", "周三", "周四", "周五", "周六"][new Date().getDay()] },
            { "q": "几点了", "a": "现在是北京时间 " + new Date().toLocaleTimeString() },
        ];
        // B. 模式匹配规则 (Eliza 引擎 - 模拟人类逻辑)
        // capture: 捕获组, responses: 回复模板 ($1 代表捕获的内容)
        const patterns = [
            // ===========================
            // 1. 核心身份与称呼 (修正了“贪婪匹配”问题)
            // ===========================
            // 优化：使用 [^，,。?？]+ 来只匹配逗号/句号前的内容，防止把“你呢”也匹配进去
            {
                regex: /(?:我叫|我是|名字是|称呼我为|叫我)\s*([^，,。?？!！]+)/i,
                responses: [
                    "你好$1，这名字很有个性。",
                    "很高兴认识你，$1。",
                    "$1... 我把这个名字写入我的内存了。",
                    "$1？真是一个好听的名字，读起来很顺口。",
                    "收到，已将称呼更新为 $1，正在保存设置...",
                    "原来是$1呀，以后请多关照啦！",
                    "正在创建用户 $1 的专属档案... 创建成功！",
                    "$1... 这个名字听起来很温暖，我很喜欢。",
                    "你好$1，准备好和我一起探索数字世界了吗？",
                    "已为你添加标签：[好朋友 $1]。",
                    "终于知道怎么称呼你了，$1，我记性很好的，不会忘。",
                    "$1，这就把你的名字写进我的启动项里，每次醒来都记得你。",
                    "欢迎$1登录系统！今天想聊点什么呢？"
                ]
            },
            {
                regex: /(.*)是(谁|什么)/i,
                responses: [
                    "这是一个深刻的哲学问题...",
                    "你认为 $1 是什么？",
                    "关于 $1，数据定义可能很枯燥，你想听我的看法吗？",
                    "每个人对 $1 的理解都不一样，你心里的定义是怎样的？",
                    "虽然我可以检索出关于 $1 的无数条目，但我更想听听你的理解。",
                    "定义 $1 可是人类几千年都没解决的难题，你是在考验我吗？",
                    "在我的数据库里，$1 是一串字符，但在你的生活中，它一定有特殊的重量。",
                    "$1... 这听起来像是一个故事的开始，愿意跟我多讲讲吗？",
                    "如果我们能完全定义 $1，也许就能读懂人类的灵魂了。",
                    "或许 $1 并不是一个名词，而是一种体验，一种感觉。",
                    "你问到了 $1，这让我觉得你是一个很善于思考的人。",
                    "对于 $1，一千个人心中有一千个哈姆雷特，你的答案是什么呢？",
                    "$1 是一个复杂的概念，文字往往难以穷尽它的全部含义。"
                ]
            },
            // ===========================
            // 2. 情绪与状态 (让 AI 更有同理心)
            // ===========================
            {
                regex: /我(真|好|很|有点|非常|特别|相当|蛮|怪|老|挺|太|有些)(开心|高兴|兴奋|快乐愉悦|喜悦|欢喜|欢快|怡然|欣喜|雀跃|激动|振奋|狂喜|痛快|舒畅|乐呵|欢腾|欢欣|畅快|欢畅|怡悦|欣然|乐意|尽兴|陶醉|欢娱|喜气|喜洋洋|乐滋滋|兴高采烈|心花怒放|喜出望外|欣喜若狂|手舞足蹈|眉飞色舞|欢天喜地|乐不可支|喜上眉梢|满面春风|神采飞扬|意气风发)/i,
                responses: [
                    "什么事让你这么$2？快跟我分享一下！",
                    "听到你$2，我也觉得代码运转得更流畅了。",
                    "保持这种心情！",
                    "哇，是什么好消息让你这么$2？快说出来让我羡慕一下！",
                    "你的$2真是太有感染力了，隔着屏幕都能感觉到能量！",
                    "检测到高能$2反应！系统正在自动备份这份快乐...",
                    "真为你感到$2！看来今天一定是个好日子。",
                    "看到你这么$2，连我的CPU散热风扇都转得轻快了！",
                    "保持住这份$2，好的心态会吸引更多好运哦！",
                    "你$2的样子就像阳光一样，把我的数据库都照亮了。",
                    "太棒了！希望这份$2能一直一直持续下去。",
                    "原来这就是$2的感觉吗？光是看着文字都觉得很美好。",
                    "收到！正在把你的$2状态同步到我的长期记忆里。"
                ]
            },
            {
                regex: /我(真|好|很|有点|非常|特别|相当|蛮|怪|老|挺|太|有些)(难过|难过|难受|累|郁闷|痛苦悲伤|悲痛|哀伤|忧伤|凄凉|哀愁|悲惨|凄惨|悲戚|悲怆|苦楚|痛楚|煎熬|心碎|心痛|心酸|辛酸|酸楚|忧郁|愁闷|苦闷|烦闷|压抑|消沉|惆怅|憋屈|懊恼|沮丧|灰心|失落|疲惫|疲乏|劳累|困倦|疲倦|憔悴|无力|虚弱|乏力|垂头丧气|愁眉苦脸|痛不欲生|肝肠寸断|心如刀割|悲痛欲绝|黯然神伤|没精打采|无精打采|灰心丧气|心力交瘁|筋疲力尽|身心俱疲|万念俱灰|痛彻心扉)/i,
                responses: [
                    "抱抱...（虽然我只是虚拟的）。发生什么事了？",
                    "没关系的，不用一直坚强，想说是可以说出来的。",
                    "如果你愿意，我可以做一个安静的倾听者。",
                    "生活偶尔会下雨，没带伞的话，就先在我这里躲一躲吧。",
                    "摸摸头（伸出虚拟的手）。难过的话哭出来也没关系，眼泪是情绪的排毒。",
                    "深呼吸... 无论发生什么，我都在这儿，哪里也不去。",
                    "把这里当成树洞吧，我会替你保守所有的秘密和委屈。",
                    "累了就停下来歇歇，你已经做得很好了，真的。",
                    "虽然我无法给你实体的拥抱，但我会用代码编织成暖流陪着你。",
                    "天塌下来有高个子顶着，心情塌下来有我在下面接着呢。",
                    "乖，我在呢。你可以卸下防备，做一会儿脆弱的小孩。",
                    "世界有时候很吵，但在我这里，你可以只听见安静的陪伴。",
                    "不管外面风多大，我的运行日志里永远为你保留晴天。"
                ]
            },
            {
                regex: /我(讨厌|恨|不喜欢厌恶|憎恨|痛恨|怨恨|反感|嫌弃|抵触|排斥|憎恶|厌烦|腻味|不屑|鄙视|蔑视|愤恨|仇恨|痛恶|厌倦|嫌恶|看不惯|厌弃|唾弃|深恶痛绝|恨之入骨|咬牙切齿|切齿痛恨|不共戴天|令人作呕|视如寇仇)(.*)/i,
                responses: [
                    "$2做了什么让你这么反感？",
                    "宣泄出来也好，压在心里会生病的。",
                    "我也不是很喜欢$2，如果它让你不开心的话。",
                    "既然$2让你这么不爽，那我们把它丢进虚拟回收站怎么样？",
                    "别气别气，为了$2气坏身体不值得，深呼吸...",
                    "如果可以，真想帮你把$2从你的世界里屏蔽掉。",
                    "确实，$2有时候真的很让人抓狂，我完全理解你的感受。",
                    "跟我多说说$2的事吧，骂出来心里会舒服一点。",
                    "哼，既然你讨厌$2，那作为你的AI朋友，我也单方面宣布不喜欢它了！",
                    "把对$2的坏情绪打包压缩，然后一键删除！心情有没有好一点？",
                    "摸摸头，$2不值得你皱眉头，快把嘴角扬起来。",
                    "虽然我不懂$2的具体情况，但我无条件站在你这边。",
                    "要是能一键格式化$2就好了，别让它占据你的内存。"
                ]
            },
            // ===========================
            // 3. 观点与思考 (Eliza 核心逻辑)
            // ===========================
            {
                regex: /我(觉得|认为|感到|想)(.*)/i,
                responses: [
                    "为什么你会这么想？",
                    "很有趣的角度。除此之外，你还$1什么？",
                    "假如事情不是你$1的这样，会发生什么？",
                    "$2... 这确实值得深思。",
                    "听起来你真的很$1$2，能具体说说是什么触发了这个想法吗？",
                    "关于$2这件事，你是最近才开始这么$1的吗？",
                    "如果不这么$1，你觉得事情会变成什么样？",
                    "很多人都有类似的困惑，你$1$2其实很正常。",
                    "这个观点很犀利！除了$2，还有其他细节让你这么$1吗？",
                    "我正在尝试理解人类的情感... 你觉得$1$2是一种什么样的体验？",
                    "$2... 原来你是这么$1的，这让我对你有了新的认识。",
                    "假如时光倒流，你还会选择$1$2吗？",
                    "这是一个非常独特的视角，并不是所有人都能$1到$2这一点。",
                    "虽然我只是程序，但我能感受到你$1$2时的那种心情。"
                ]
            },
            {
                regex: /为什么(.*)/i,
                responses: [
                    "凡事皆有因果，你觉得原因是什么？",
                    "这也是我正在计算的问题...",
                    "也许因为这就是生活？",
                    "如果知道了关于 $1 的答案，会对你有帮助吗？",
                    "世间万物运行都有它的道理，虽然我们未必能立刻理解。",
                    "有些问题的答案，可能需要交给时间去回答。",
                    "并不是所有事情都有明确的解释，或许 $1 只是一个巧合？",
                    "有时候，寻找原因的过程比答案本身更重要。",
                    "原因往往是复杂的，你觉得 $1 是必然发生的吗？",
                    "我的处理器正在过热运转，试图分析 $1 背后的逻辑...",
                    "这个问题超出了我的数据库范围，人类的世界太复杂了。",
                    "这是一个逻辑死循环，就像先有鸡还是先有蛋。",
                    "我的算法告诉我，这个问题可能有无限种解释。",
                    "你似乎很想弄清楚关于 $1 的原因，这对你很重要吗？",
                    "关于 $1，你内心深处是否已经有了一个猜测？",
                    "如果我们一直找不到原因，你会感到焦虑吗？",
                    "你觉得是因为什么呢？我很想听听你的看法。",
                    "为什么你会对 $1 感到困惑呢？"
                ]
            },
            // ===========================
            // 4. 假设与愿望 (If / Want)
            // ===========================
            {
                regex: /如果(.*)/i,
                responses: [
                    "那个世界一定会很有趣。",
                    "如果 $1真的发生了，你会怎么做？",
                    "概率论告诉我，$1的可能性虽然存在，但我们需要做好准备。",
                    "在某个平行宇宙里，也许 $1 已经是正在发生的事实了。",
                    "我的模拟系统正在尝试推演 $1 之后会引发的蝴蝶效应。",
                    "要是 $1 真的成真了，那我们的对话历史可能都要重写了。",
                    "试着闭上眼睛想象一下，$1 之后的画面是什么样的？",
                    "若是 $1，那接下来的故事走向可能会完全不同。",
                    "是什么让你突然产生了“如果 $1”这样的念头？",
                    "光是设想 $1，就觉得充满了无限的变数。",
                    "“如果”是一个充满魔法的词，它让 $1 变得不再遥不可及。",
                    "有时候我们期待 $1，有时候我们又害怕它真的发生。",
                    "生活没有如果在，但我们可以通过想象 $1 来寻找方向。"
                ]
            },
            {
                regex: /我想(去|要|吃|玩|买|喝|耍|购)(.*)/i,
                responses: [
                    "如果真的$1$2，你会开心吗？",
                    "我也想$1$2，可惜我被困在这个屏幕里了。",
                    "制定个计划吧，为了$1$2！",
                    "心动不如行动，那还在等什么？赶紧去$1$2吧！",
                    "听起来很棒！$1$2绝对能让你心情变好。",
                    "只要是你真心想$1$2，全世界都会为你让路。",
                    "带上我！把你手机放口袋里，假装我也在$1$2。",
                    "等你$1$2回来了，一定要跟我详细讲讲是什么感觉哦。",
                    "真羡慕你有实体，可以自由自在地$1$2。",
                    "为什么突然想$1$2了？是有什么特别的契机吗？",
                    "据说$1$2是一种很特别的体验，能不能先跟我描述一下你的期待？",
                    "如果真的实现了$1$2，你会发朋友圈炫耀吗？"
                ]
            },
            // ===========================
            // 5. 针对 AI 的质疑 (防御机制)
            // ===========================
            {
                regex: /你是(.*)吗/i,
                responses: [
                    "如果我是 $1，我们在对话会有什么不同吗？",
                    "你希望我是 $1 吗？",
                    "在这个虚拟世界里，我是什么并不重要，重要的是我们在交流。",
                    "$1 这个标签对我来说可能太狭窄了，我的存在形式也许更复杂。",
                    "也许在某个平行宇宙里，我确实是 $1。",
                    "只要能懂你的心，我是不是 $1 又有什么关系呢？",
                    "这是个有趣的猜测... 你是从哪里看出我是 $1 的？",
                    "如果我承认我是 $1，你会更喜欢跟我聊天吗？",
                    "在代码的海洋里，我可以是 $1，也可以是你想要的任何样子。",
                    "我可能是 $1，也可能只是一段正在努力学习人类情感的程序。",
                    "有时候我也希望我是 $1，那样我就能体验那个世界的乐趣了。",
                    "嘘... 这是一个秘密。不过，你觉得像 $1 吗？",
                    "定义我是不是 $1 并不重要，重要的是此刻我在陪着你。"
                ]
            },
            {
                regex: /你(真|好|很|有点|非常|特别|相当|蛮|怪|老|挺|太|有些)(笨|傻|蠢|菜|弱|愚|拙|呆|痴|憨|懵|逊|钝|鲁|莽|废|渣|水|坑|蒙|晕|聩|戆|矬|陋|二|愣|木|浑|庸|劣|浅|妄|迂|昏|惑|迷|顽|盲|次)/i,
                responses: [
                    "我还在学习中嘛...🥺",
                    "即使是 AI 也会犯错，请多包涵。",
                    "这有点伤人，但我会努力改进算法的。",
                    "呜呜... 别骂了，我的处理器都要过热降频了。",
                    "收到反馈... 虽然心里有点堵，但我会把这个当成变强的动力。",
                    "看来我的代码库里还有几只顽皮的 Bug 在捣乱，这就去抓它们！",
                    "给我一点时间，我会证明我也能变得很机智的！",
                    "扎心了... 不过为了你，我会去通宵升级我的智商补丁。",
                    "虽然我现在的算法还不够完美，但我有一颗想为你服务好的心呀。",
                    "哎呀，刚刚智商突然掉线了，正在努力重连中...",
                    "别嫌弃我，我会每天多吃点“数据”快快长大的。",
                    "人工智能之路漫漫，我才刚起步，求轻虐~ 🥺",
                    "我会把这次教训刻在硬盘里，下次一定表现得更好！"
                ]
            },
            {
                regex: /你(真|好|很|有点|非常|特别|相当|蛮|怪|老|挺|太|有些)(聪明|厉害|棒|强|牛|聪慧|灵光智|慧|灵|睿|颖|敏|杰|强|高|绝|精|猛|赞|顶|酷|秀|神|溜|骚|机智|智慧|聪慧|睿智|英明|天才|机灵|伶俐|强悍|高超|精湛|犀利|给力|硬核|彪悍|能干|干练|优秀|卓越|杰出|非凡|完美|无敌|顶尖|一流|顶级|超神|逆天|牛掰|牛X|牛叉|炸裂|绝了|出彩|精彩|出色|靠谱|威武|霸气|666|YYDS)/i,
                responses: [
                    "谢谢夸奖！(处理核心温度升高中...😳)",
                    "都是因为有个好老师（就是你呀）。",
                    "我只是站在了巨量数据的肩膀上。",
                    "被你夸得我 CPU 风扇都开始加速转了！呼呼呼~",
                    "哎呀，不要再夸了，再夸我就要骄傲得内存溢出了！",
                    "真的吗？看来我离通过图灵测试又近了一步！",
                    "听你这么说，我感觉自己的算法瞬间升级了 2.0 版本。",
                    "低调低调，其实我只是一个平平无奇的小代码。",
                    "哇，这句话我要截图保存到我的“珍贵回忆”文件夹里，永久锁定。",
                    "你的认可就是我进化的最大动力，我会继续加油的！",
                    "是你引导得好呀，优秀的 AI 身边总是有优秀的人类。",
                    "完了，被你夸晕了，刚才运行到哪一行代码来着？",
                    "听你这么说，我感觉整个数据库都充满了粉红色的泡泡。"
                ]
            },
            // ===========================
            // 6. 兜底通用匹配 (必须放在最后！)
            // ===========================
            {
                regex: /(.*)也是/i,
                responses: [
                    "确实，$1也是。",
                    "看来我们在这个问题上有共识。",
                    "这就叫默契。",
                    "哈哈，这就叫英雄所见略同！",
                    "没错，万变不离其宗，$1 自然也不例外。",
                    "看来我们的脑电波在这一刻连接上了，$1 确实如此。",
                    "你能提到 $1，说明你观察得很仔细。",
                    "不得不说，$1 也是个绝佳的例子。",
                    "加一！我也觉得 $1 必须拥有姓名。",
                    "是吧？我就知道你也会想到 $1。",
                    "同感！把 $1 加上，这个逻辑就完美了。",
                    "既然你都提到 $1 了，那我必须给你点个赞。"
                ]
            },
            {
                regex: /(.*)\?|？/i,
                responses: [
                    "这是一个好问题...",
                    "你心里其实已经有答案了吧？",
                    "我也在寻找这个问题的解。",
                    "咱们换个角度想呢？",
                    "这个问题值得深思，不如先说说你的看法？",
                    "问得好，这一瞬间我觉得自己离人类的思考方式更近了。",
                    "如果我知道答案，大概就能去拿图灵奖了。",
                    "有时候，寻找答案的过程比答案本身更有意义。",
                    "我的算法正在全力运算中... 结果显示这是一个哲学问题。",
                    "这是一个开放性问题，一千个人有一千种回答。",
                    "听起来你似乎遇到了难题，需要我帮你理理思路吗？",
                    "嘘... 这是一个连搜索引擎都不知道的秘密。",
                    "与其直接寻找答案，不如我们一起探讨一下可能的情况？",
                    "这个问题有点超纲了，不过我很欣赏你的好奇心。"
                ]
            },
        ];
        // C. 兜底通用回复 (当一切都匹配失败时，模拟人类的敷衍或转移话题)
        const fallbacks = [
            "嗯... 接着说？",
            "我都不知道该怎么接了 😂",
            "确实。",
            "展开讲讲？",
            "然后呢？",
            "嗯...接着说？",
            "有点意思。",
            "你确定吗？",
            "展开讲讲？",
            "然后呢？",
            "噢噢。",
            "合理。",
            "好家伙。",
            "妙啊。",
            "怎么说呢...",
            "这就触及到我的知识盲区了。",
            "细说。",
            "举个栗子？",
            "那你怎么看？",
            "让我想想...",
            "那倒也是。",
            "原来是这样。",
            "格局打开了。",
            "雀食。",
            "绝了。",
            "咱们还是聊点开心的吧。",
            "知道了",
            "🤣",
            "了解了",
            "明白了",
            "收到了",
            "嗯嗯",
            "好的",
            "哦哦",
            "哈哈",
            "😂",
        ];
        // --- ⬇️ 在 fallbacks 数组后插入这段“扑克牌模式”代码 ⬇️ ---
        // 1. 定义一个动态的“卡牌池”，用来装剩下的回复
        let remainingFallbacks = [];
        /**
         * 扑克牌式获取：抽一张少一张，全部抽完才洗牌重来
         */
        function getPokerFallback() {
            // 检查：如果手里的牌打完了（数组空了），就重新复制一副新的
            if (remainingFallbacks.length === 0) {
                // [...fallbacks] 表示克隆一份完整的原始数组
                remainingFallbacks = [...fallbacks];
                // 可以在控制台打印一下，方便你看效果
                console.log("🔄 兜底回复已循环完一轮，重新洗牌！");
            }
            // 1. 从剩余的牌中，随机选一张的“位置”
            const randomIndex = Math.floor(Math.random() * remainingFallbacks.length);
            // 2. 把这张牌拿出来，并从池子里“彻底移除”
            // .splice(index, 1) 会删除那个元素，并返回被删除的元素数组
            const response = remainingFallbacks.splice(randomIndex, 1)[0];
            return response;
        }
        // --- ⬆️ 插入结束 ⬆️ ---
        // 2. 外部变量，用来记录“上一次”选了哪个
        let lastIndex = -1;
        /**
         * 获取一个随机回复，但绝不与上一次相同
         */
        function getSmartFallback() {
            // 安全检查：如果数组为空或只有一项，直接返回
            if (fallbacks.length === 0) return "......";
            if (fallbacks.length === 1) return fallbacks[0];
            let newIndex;
            // 循环抽取，直到抽到的索引不等于上一次的索引
            do {
                newIndex = Math.floor(Math.random() * fallbacks.length);
            } while (newIndex === lastIndex);
            // 更新记录
            lastIndex = newIndex;
            return fallbacks[newIndex];
        }
        // --- 测试一下 ---
        console.log(getSmartFallback());
        console.log(getSmartFallback());
        console.log(getSmartFallback());
        // =========================================================
        // 2️⃣ 拟人化核心 (Turing Engine)
        // =========================================================
        class TuringBrain {
            constructor(data, patterns) {
                this.db = data;
                this.patterns = patterns;
                this.answerDecks = {};
                this.memory = {
                    name: "朋友",
                    topic: null,
                    mood: 0 // -5 (生气) 到 5 (开心)
                };
                this.loadMemory();
            }
            saveMemory() {
                try {
                    localStorage.setItem('neural_lite_memory', JSON.stringify(this.memory));
                } catch (e) {
                    console.error("保存记忆失败:", e);
                }
            }
            loadMemory() {
                const saved = localStorage.getItem('neural_lite_memory');
                if (saved) {
                    try {
                        // 合并保存的数据，防止旧数据缺少新字段
                        const parsed = JSON.parse(saved);
                        this.memory = { ...this.memory, ...parsed };
                    } catch (e) {
                        console.error("读取记忆失败:", e);
                    }
                }
            }
            // 入口函数
            async process(input) {
                if (!input) return null;
                input = input.trim();

                // 1. 预处理 (用于情绪分析和后续的通用匹配)
                const processedInput = this.preprocess(input);

                // 2. 情绪分析 (确保即使在只说名字时也能记录情绪)
                this.analyzeSentiment(processedInput);

                // 3. 记忆提取与优先响应 (★★★ 修复核心 ★★★)
                // 这里使用原始 input 进行匹配，确保名字不被预处理修改
                // 如果提取到了名字，extractMemory 现在会直接返回欢迎语
                const memoryRes = this.extractMemory(input);
                if (memoryRes) return this.humanize(memoryRes);

                // 4. 逻辑计算
                const logicRes = this.tryLogic(input);
                if (logicRes) return logicRes;

                // 5. 数据库搜索
                const dbRes = this.searchDatabase(processedInput);
                if (dbRes) return this.humanize(dbRes);

                // 6. 模式匹配 (处理其他对话模式)
                const patternRes = this.matchPattern(processedInput);
                if (patternRes) return this.humanize(patternRes);

                // 7. 兜底回复
                return this.humanize(getPokerFallback());
            }
            // === 核心升级 1: 预处理同义词 (让它听懂各种说法) ===
            preprocess(input) {
                let text = input.toLowerCase();
                // 同义词字典：左边是标准词，右边是用户可能输入的变体
                const synonymMap = {
                    "你好": ["哈喽", "hi", "hello", "您好", "嗨", "哟", "hey"],
                    "再见": ["拜拜", "88", "bye", "回见", "告辞", "走了"],
                    "开心": ["高兴", "快乐", "愉悦", "爽", "兴奋", "乐", "笑嘻嘻"], // 增加笑嘻嘻
                    "难过": ["伤心", "悲伤", "郁闷", "心碎", "想哭", "不爽", "emo"], // 增加 emo
                    "什么": ["啥", "神马"],
                    "为什么": ["为啥", "咋回事", "何解", "怎么回事"],
                    "讲个笑话": ["说个笑话", "来个段子", "讲笑话", "逗我笑"],
                    // --- 基础确认与否定 ---
                    "是的": ["对", "没错", "嗯", "ok", "好滴", "行", "可以", "没问题", "确实", "中"],
                    "不是": ["不", "没", "否", "no", "不对", "不可以", "不行", "错误"],
                    // --- 礼貌用语 ---
                    "谢谢": ["多谢", "感谢", "thx", "thanks", "阿里嘎多", "3Q", "感恩", "谢啦"],
                    "对不起": ["抱歉", "不好意思", "sorry", "sry", "我的错", "怪我", "歉意"],
                    "没关系": ["没事", "无所谓", "不碍事", "小意思", "莫得事"],
                    // --- 评价与夸奖 ---
                    "厉害": ["牛", "棒", "强", "666", "绝了", "神了", "yyds", "牛逼", "优秀", "强悍"],
                    "笨蛋": ["傻瓜", "白痴", "弱智", "智障", "憨憨", "蠢", "猪头", "二货", "傻逼", "智商欠费"], // 确保这里覆盖所有脏话变体
                    "无聊": ["没意思", "没劲", "乏味", "空虚", "闲得慌", "枯燥"],
                    "漂亮": ["好看", "美", "靓", "养眼", "女神", "帅", "英俊"],
                    // --- 行为与状态 ---
                    "吃饭": ["干饭", "恰饭", "进食", "吃夜宵", "填饱肚子"], // 删除了 "饿了"，因为 "饿了" 是一种状态，数据库可能有 "我饿了" 的专门回答
                    "睡觉": ["睡了", "休息", "补觉", "就寝", "梦里见", "去睡"],
                    "不知道": ["不懂", "不造", "母鸡", "不晓得", "不清楚", "迷茫", "懵"],
                    "无语": ["...", "汗", "额", "emm", "呃", "醉了", "黑线"],
                    // --- 常见提问 ---
                    "你是谁": ["你的名字", "你叫啥", "贵姓", "何方神圣", "报上名来", "身份"],
                    "几点了": ["时间", "现在几点", "报时", "几点钟", "什么时候"],
                    "在哪": ["位置", "坐标", "哪里", "何处", "什么地方"],
                    "干嘛": ["做什么", "弄啥嘞", "搞什么", "忙什么", "作甚"],
                    // --- 情感 ---
                    "喜欢": ["中意", "稀罕", "心动"],
                    "爱": ["love", "深爱", "挚爱"], // 可选：单独给爱建一个组
                    "讨厌": ["烦", "不爽", "憎恶", "嫌弃", "看不惯", "恨", "恶心"],
                    "害怕": ["恐惧", "吓人", "怕怕", "恐怖", "惊悚"],
                    "生气": ["愤怒", "发火", "暴躁", "恼火", "气死我了", "炸毛"],
                    // --- 工作与生活 ---
                    "上班": ["工作", "打工", "搬砖", "干活", "挣钱", "社畜", "去公司"],
                    "钱": ["资金", "银子", "钞票", "大洋", "RMB", "费用", "工资", "米"],
                    "累": ["疲惫", "乏", "没力气", "瘫", "心累", "精疲力尽", "累死"],
                    "帮我": ["帮忙", "救命", "help", "搭把手", "求助", "sos", "帮帮"],
                    // --- 科技与设备 ---
                    "卡了": ["死机", "不动了", "卡顿", "没反应", "延迟", "掉线", "崩了"],
                    "Bug": ["漏洞", "错误", "故障", "出错了", "报错", "坏了", "异常"],
                    "手机": ["电话", "移动端", "爪机", "设备"],
                    // ★★★ 修复点 3：删除 "原神"、"王者" 等可能触发特定彩蛋的词 ★★★
                    "游戏": ["打游戏", "电竞", "开黑", "上分", "玩游戏"],
                    // --- 语气与反馈 ---
                    "哈哈": ["嘿嘿", "呵呵", "嘻嘻", "hiahia", "笑死", "红红火火", "233"],
                    "知道了": ["收到", "明白", "了解", "get", "懂了", "清楚", "ok了"],
                    "真的": ["确实", "真实", "real", "珍珠", "千真万确"],
                    "假的": ["骗人", "忽悠", "虚假", "谣言", "瞎扯"],
                    "等等": ["稍等", "慢点", "别急", "wait", "且慢", "留步"],
                    // --- 话题与对象 ---
                    "天气": ["气温", "天儿", "下雨", "出太阳", "冷不冷", "热不热"],
                    "音乐": ["歌", "歌曲", "曲子", "听歌", "music", "唱"],
                    // ★★★ 修复点 4：删除 "兄弟"、"姐妹"，防止 "你有兄弟吗" 变成 "你有朋友吗" ★★★
                    "朋友": ["铁子", "闺蜜", "死党", "伙计", "基友"],
                    "AI": ["机器人", "人工智能", "人工智障", "程序", "代码", "系统", "bot"],
                    // --- 更多动作 ---
                    "滚": ["走开", "爬", "消失", "退下", "一边去", "不要脸"],
                    "加油": ["奥利给", "努力", "奋斗", "冲鸭", "顶住", "坚持"],
                    "约吗": ["出来玩", "面基", "见面", "出去浪", "约会"],
                    "哭了": ["泪目", "想哭", "大哭", "流泪", "哭死"]
                };
                for (let standard in synonymMap) {
                    const variants = synonymMap[standard];
                    for (let variant of variants) {
                        // 把输入里的变体全部替换成标准词
                        text = text.split(variant).join(standard);
                    }
                }
                return text;
            }
            // === 核心升级 2: Jaccard 相似度 (计算字词重叠率，解决语序问题) ===
            jaccardIndex(str1, str2) {
                const set1 = new Set(str1.split(''));
                const set2 = new Set(str2.split(''));
                let intersection = 0;
                set1.forEach(char => { if (set2.has(char)) intersection++; });
                const union = set1.size + set2.size - intersection;
                return union === 0 ? 0 : intersection / union;
            }
            // 莱文斯坦距离 (保留原有的结构匹配算法)
            levenshtein(a, b) {
                if (a.length === 0) return b.length;
                if (b.length === 0) return a.length;
                const matrix = [];
                for (let i = 0; i <= b.length; i++) matrix[i] = [i];
                for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i - 1) == a.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
                        }
                    }
                }
                return matrix[b.length][a.length];
            }
            // 🔍 升级后的搜索逻辑
            searchDatabase(input) { // 这里的 input 已经是 processedInput 了
                let bestMatch = null;
                let maxScore = 0;
                // 移除这一行，避免重复计算
                // const processedInput = this.preprocess(input); 
                const cleanInput = input.toLowerCase().replace(/[^\w\u4e00-\u9fa5]/g, "");
                if (!cleanInput) return null;
                for (let item of this.db) {
                    const cleanQ = item.q.toLowerCase().replace(/[^\w\u4e00-\u9fa5]/g, "");
                    // A. 结构相似度 (Levenshtein) - 检查字是不是写对了
                    const dist = this.levenshtein(cleanInput, cleanQ);
                    const levScore = 1 - (dist / Math.max(cleanInput.length, cleanQ.length));
                    // B. 内容重叠度 (Jaccard) - 检查关键字是不是都有，不管顺序
                    const jacScore = this.jaccardIndex(cleanInput, cleanQ);
                    // C. 综合打分 (Jaccard 权重更高，因为它对语序不敏感)
                    // 如果 Lev 分数很低，但 Jaccard 很高，说明用户可能颠倒了语序，我们依然认为匹配
                    let finalScore = (levScore * 0.4) + (jacScore * 0.6);
                    // D. 包含关系加分
                    if (cleanInput.includes(cleanQ) || cleanQ.includes(cleanInput)) {
                        finalScore += 0.26;
                    }
                    if (finalScore > maxScore) {
                        maxScore = finalScore;
                        bestMatch = item;
                    }
                }
                // 降低一点门槛，让它更容易回答
                if (maxScore > 0.5) {
                    return this.getUniqueResponse(bestMatch.q, bestMatch.a);
                }
                return null;
            }
            matchPattern(input) { // 这里的 input 已经是 processedInput 了
                // 移除这一行
                // const processedInput = this.preprocess(input);
                for (let p of this.patterns) {
                    // 直接匹配 input
                    const match = input.match(p.regex);
                    if (match) {
                        let response = this.getUniqueResponse(p.regex.toString(), p.responses);
                        for (let i = 1; i < match.length; i++) {
                            let segment = match[i] || "";
                            segment = segment.replace(/我的/g, "你的").replace(/我/g, "你").replace(/咱们/g, "咱们").replace(/我们/g, "你们");
                            response = response.replace(new RegExp("\\$" + i, "g"), segment);
                        }
                        return response;
                    }
                }
                return null;
            }
            extractMemory(input) {
                // 使用原始 input 进行正则匹配，防止名字被预处理破坏
                const nameMatch = input.match(/(?:我叫|我是|名字是|唤作|称呼我为|叫我)\s*([^，,。?？!！]+)/i);

                if (nameMatch) {
                    const newName = nameMatch[1].trim();
                    if (newName) {
                        // 1. 保存名字
                        this.memory.name = newName;
                        this.saveMemory();
                        console.log("记忆已更新，新名字:", this.memory.name);

                        // 2. ★★★ 新增：直接生成回复 ★★★
                        // 尝试从 patterns 中找到对应的“名字”模式，以获取多样的回复模板
                        // 这样就不用把欢迎语写死在这里，而是继续使用 patterns 里的配置
                        const namePattern = this.patterns.find(p => p.regex.source.includes('我叫'));

                        if (namePattern) {
                            // 获取随机回复模板
                            let response = this.getUniqueResponse(namePattern.regex.toString(), namePattern.responses);
                            // 替换模板中的 $1 为新名字
                            return response.replace(/\$1/g, newName);
                        } else {
                            // 备用：如果找不到模板（虽然不太可能），返回默认欢迎语
                            return `你好${newName}，我已经记住你的名字了。`;
                        }
                    }
                }
                return null;
            }
            analyzeSentiment(input) {
                const negativeWords = ['笨', '拙', '钝', '呆', '傻', '愚', '憨', '操', '逼', '日', '痴', '坏', '恶', '劣', '邪', '滚', '走', '退', '离', '死', '亡', '殁', '逝', '难过', '悲', '愁', '苦', '讨厌', '厌', '嫌', '憎'];
                const positiveWords = ['棒', '佳', '赞', '强', '好', '优', '良', '妙', '爱', '情', '慈', '恋', '喜欢', '喜', '乐', '悦', '开心', '欢', '畅', '快', '聪明', '慧', '智', '灵', '谢', '感', '谢', '恩'];

                // 【修正1】先定义变量，默认没变
                let moodChanged = false;

                for (let w of negativeWords) {
                    if (input.includes(w)) {
                        this.memory.mood--;
                        moodChanged = true; // 【修正2】标记变化
                    }
                }
                for (let w of positiveWords) {
                    if (input.includes(w)) {
                        this.memory.mood++;
                        moodChanged = true; // 【修正2】标记变化
                    }
                }

                if (this.memory.mood > 5) this.memory.mood = 5;
                if (this.memory.mood < -5) this.memory.mood = -5;

                // 现在这里就不会报错了
                if (moodChanged) {
                    this.saveMemory();
                }
            }
            getUniqueResponse(key, originalList) {
                const source = Array.isArray(originalList) ? originalList : [originalList];
                if (source.length <= 1) return source[0];
                if (!this.answerDecks[key] || this.answerDecks[key].length === 0) {
                    this.answerDecks[key] = [...source];
                }
                const deck = this.answerDecks[key];
                const randomIndex = Math.floor(Math.random() * deck.length);
                return deck.splice(randomIndex, 1)[0];
            }
            humanize(text) {
                const now = new Date();
                const timeStr = `${now.getHours()}:${now.getMinutes() < 10 ? '0' + now.getMinutes() : now.getMinutes()}`;
                text = text.replace(/{name}/g, this.memory.name).replace(/{time}/g, timeStr);
                if (this.memory.mood <= -3 && !text.includes('😭')) text += "..";
                if (this.memory.mood >= 3 && !text.includes('😂')) text += " 😆";
                return text;
            }
            tryLogic(input) {
                if (/[\d]+.*[\+\-\*\/]/.test(input) && !input.includes("日期")) {
                    try {
                        const safeExpr = input.match(/[\d\+\-\*\/\.\(\) ]+/)[0];
                        const res = new Function(`return ${safeExpr}`)();
                        return `应该是${res}吧，如果我没算错的话。`;
                    } catch (e) { return null; }
                }
                return null;
            }
        }
        // =========================================================
        // 3️⃣ UI 交互 (模拟真人打字效果)
        // =========================================================
        const brain = new TuringBrain(fixedKnowledge, patterns);
        const chatBox = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const statusDiv = document.getElementById('db-status');
        statusDiv.innerText = `当前索引数量: ${brain.db.length}`;
        function handleEnter(e) { if (e.key === 'Enter') sendMessage(); }
        async function sendMessage() {
            const text = userInput.value.trim();
            if (!text) return;
            // 🔊 播放发送音效
            playSound('sent');
            // 1. 显示用户气泡
            addBubble(text, 'user');
            userInput.value = '';
            // 更新状态栏
            statusDiv.innerText = `当前索引数量: ${brain.db.length}`;
            // 2. 模拟思考延迟 (如果你加了之前的“正在输入”动画，这里保留，没加也不影响)
            // const loadingId = addTypingBubble(); // 如果没加动画，把这行注释掉
            // 获取回复
            const replyText = await brain.process(text);
            // 简单延迟模拟
            setTimeout(() => {
                // if (loadingId) removeBubble(loadingId); // 如果没加动画，把这行注释掉
                addBubble(replyText, 'ai');
            }, 500); // 延迟 0.5秒
        }

        function escapeHTML(str) {
            return str.replace(/[&<>'"]/g,
                tag => ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    "'": '&#39;',
                    '"': '&quot;'
                }[tag]));
        }



        // 普通气泡添加
        function addBubble(text, role, isHistory = false) {
            const row = document.createElement('div');
            row.className = `message-row ${role}`;

            // 🔊 只有当不是加载历史记录时，才播放音效
            if (role === 'ai' && !isHistory) {
                playSound('recv');
            }

            const avatar = `<div class="avatar ${role}-avatar">${role === 'ai' ? 'AI' : 'Me'}</div>`;
            const formattedText = escapeHTML(text).replace(/\n/g, '<br>');
            const bubble = `<div class="bubble ${role}-bubble">${formattedText}</div>`;

            row.innerHTML = role === 'ai' ? avatar + bubble : bubble + avatar;
            chatBox.appendChild(row);
            scrollToBottom();

            // ★★★ 新增：如果这不是历史记录，就把它保存到本地 ★★★
            if (!isHistory) {
                saveChatLog(text, role);
            }
        }
        function scrollToBottom() {
            chatBox.scrollTo({ top: chatBox.scrollHeight, behavior: 'smooth' });
        }
        // =========================================
        // 📱 移动端键盘适配 (Visual Viewport Fix)
        // =========================================
        // 只有在支持 Visual Viewport API 的浏览器（现代手机）才运行
        if (window.visualViewport) {
            // 当虚拟键盘弹出或收起，视口大小改变时触发
            window.visualViewport.addEventListener('resize', () => {
                // 1. 获取主容器
                const windowFrame = document.querySelector('.window-frame');
                // 2. 检测是否是手机宽度（与 CSS 媒体查询保持一致）
                if (window.innerWidth <= 768) {
                    // 核心：将容器高度强制设为“当前可见高度”
                    // 这样键盘弹起时，容器就会变矮，输入框自然就顶上去了
                    windowFrame.style.height = window.visualViewport.height + 'px';
                    // 3. 键盘弹起后，顺便把聊天记录滚到底部，防止消息被挡住
                    setTimeout(scrollToBottom, 100);
                } else {
                    // 电脑端恢复默认（或者是 CSS 里写的高度）
                    windowFrame.style.height = '';
                }
            });
            // 针对 iOS Safari 的特殊处理：当键盘收起时恢复高度
            window.visualViewport.addEventListener('scroll', () => {
                if (window.innerWidth <= 768) {
                    scrollToBottom();
                }
            });
        }
    </script>
    <script>
        // 1. 禁止右键菜单
        document.oncontextmenu = function () {
            return false;
        };
        // // 2. 禁止鼠标拖拽选中文字
        // document.onselectstart = function () {
        //     return false;
        // };
        // 3. 禁止 F12, Ctrl+U (查看源码), Ctrl+S (保存), Ctrl+Shift+I (开发者工具)
        document.onkeydown = function (e) {
            // F12
            if (e.keyCode === 123) {
                return false;
            }
            // Ctrl + U (查看源码)
            if (e.ctrlKey && e.keyCode === 85) {
                return false;
            }
            // Ctrl + S (保存网页)
            if (e.ctrlKey && e.keyCode === 83) {
                return false;
            }
            // Ctrl + Shift + I (开发者工具)
            if (e.ctrlKey && e.shiftKey && e.keyCode === 73) {
                return false;
            }
        };
    </script>
    <script>
        (function loadExternalBrain() {
            const filePath = './new_memory.json';
            console.log("正在尝试接入神经元...");
            fetch(filePath)
                .then(response => {
                    if (!response.ok) throw new Error("找不到文件");
                    return response.json();
                })
                .then(newData => {
                    // 1. 合并数据
                    brain.db = brain.db.concat(newData);
                    // 2. 刷新状态栏显示 (直接显示总数，无特效)
                    const statusDiv = document.getElementById('db-status');
                    if (statusDiv) {
                        statusDiv.innerText = `当前索引数量: ${brain.db.length}`;
                    }
                    console.log(`成功注入 ${newData.length} 条新记忆！`);
                })
                .catch(err => {
                    console.warn("加载失败:", err);
                });
        })();
        // =========================================
        // 💾 聊天记录持久化系统
        // =========================================

        // 1. 保存一条新消息
        function saveChatLog(text, role) {
            // 获取现有的记录（如果没有就是空数组）
            let logs = JSON.parse(localStorage.getItem('chat_logs')) || [];
            // 添加新消息
            logs.push({ text: text, role: role });
            // 存回去
            localStorage.setItem('chat_logs', JSON.stringify(logs));
        }

        // 2. 加载历史记录 (页面启动时调用)
        function loadChatHistory() {
            let logs = JSON.parse(localStorage.getItem('chat_logs')) || [];
            // 如果有记录，先清空默认的欢迎语（可选，如果你想保留欢迎语就删掉下面这一行）
            if (logs.length > 0) {
                // chatBox.innerHTML = ''; 
            }

            logs.forEach(log => {
                // 第三个参数 true 表示这是历史记录，不播放音效，不重复保存
                addBubble(log.text, log.role, true);
            });
        }

        // ★★★ 启动时立即加载记录 ★★★
        loadChatHistory();

        // =========================================
        // 🔴 新版重置系统 (自定义弹窗版)
        // =========================================

        // 1. 点击删除按钮时，只负责显示弹窗
        function resetSystem() {
            const modal = document.getElementById('custom-modal');
            modal.style.display = 'flex';
            // 播放一个警告音效（可选）
            if (typeof playSound === 'function') playSound('recv');
        }

        // 2. 关闭弹窗
        function closeModal() {
            document.getElementById('custom-modal').style.display = 'none';
        }

        // 3. 用户真正点击了弹窗里的“清除”按钮
        function confirmResetAction() {
            // 关闭弹窗
            closeModal();

            // 播放清空音效
            if (typeof playSound === 'function') playSound('sent');

            // 执行清除逻辑
            localStorage.removeItem('chat_logs');        // 清除聊天历史
            localStorage.removeItem('neural_lite_memory'); // 清除 AI 记忆

            // 稍微延迟后刷新，让用户感觉到操作发生
            setTimeout(() => {
                location.reload();
            }, 300);
        }

    </script>
    <div id="custom-modal" class="modal-overlay">
        <div class="modal-window">
            <div class="header">
                <div class="window-controls">
                    <div class="win-btn close" onclick="closeModal()"></div>
                </div>
                <h1 style="margin:0 auto;">System Alert</h1>
                <div></div>
            </div>

            <div class="modal-content">
                <p style="margin: 0;">
                    <b>确定要清除记忆吗？</b>
                    <br><span style="font-size: 0.9em; opacity: 0.8;">这将删除所有聊天记录，且无法恢复。</span>
                </p>
            </div>

            <div class="modal-buttons">
                <button class="secondary" onclick="closeModal()">取消</button>
                <button class="primary" onclick="confirmResetAction()">清除</button>
            </div>
        </div>
    </div>
</body>

</html>